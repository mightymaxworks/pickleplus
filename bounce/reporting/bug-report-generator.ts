/**
 * PKL-278651-BOUNCE-0028-REPORT - Bug Report Generator
 * 
 * This module generates bug reports from Bounce test runs.
 * 
 * @framework Framework5.2
 * @version 1.0.0
 * @lastModified 2025-04-22
 */

import fs from 'fs/promises';
import path from 'path';
import { getTestRun, getFindings } from '../storage';
import { BounceFindingSeverity } from '../types';

/**
 * Generate a bug report for a test run
 * @param testRunId The ID of the test run
 * @returns The path to the generated report
 */
export async function generateReport(testRunId: number): Promise<string> {
  const testRun = await getTestRun(testRunId);
  if (!testRun) {
    throw new Error(`Test run ${testRunId} not found`);
  }

  const findings = await getFindings(testRunId);
  
  // Group findings by severity
  const criticalFindings = findings.filter(f => f.severity === BounceFindingSeverity.CRITICAL);
  const highFindings = findings.filter(f => f.severity === BounceFindingSeverity.HIGH);
  const moderateFindings = findings.filter(f => f.severity === BounceFindingSeverity.MODERATE);
  const lowFindings = findings.filter(f => f.severity === BounceFindingSeverity.LOW);
  
  // Format timestamp for filename
  const timestamp = new Date().toISOString().replace(/:/g, '-');
  
  // Create the report content
  let content = `# Bounce Bug Report - Test Run #${testRunId}\n\n`;
  content += `Generated on: ${new Date().toLocaleString()}\n\n`;
  
  content += `## Test Run Information\n\n`;
  content += `- **Name**: ${testRun.name}\n`;
  content += `- **Started**: ${new Date(testRun.created_at).toLocaleString()}\n`;
  content += `- **Completed**: ${testRun.completed_at ? new Date(testRun.completed_at).toLocaleString() : 'N/A'}\n`;
  content += `- **Status**: ${testRun.status}\n`;
  content += `- **Target URL**: ${testRun.base_url}\n`;
  content += `- **Total Findings**: ${findings.length}\n\n`;
  
  content += `## Summary\n\n`;
  content += `- **Critical Issues**: ${criticalFindings.length}\n`;
  content += `- **High Priority Issues**: ${highFindings.length}\n`;
  content += `- **Moderate Issues**: ${moderateFindings.length}\n`;
  content += `- **Low Priority Issues**: ${lowFindings.length}\n\n`;
  
  content += `## Findings\n\n`;
  
  if (criticalFindings.length > 0) {
    content += `### Critical Issues\n\n`;
    criticalFindings.forEach((finding, index) => {
      content += formatFinding(finding, index);
    });
  }
  
  if (highFindings.length > 0) {
    content += `### High Priority Issues\n\n`;
    highFindings.forEach((finding, index) => {
      content += formatFinding(finding, index);
    });
  }
  
  if (moderateFindings.length > 0) {
    content += `### Moderate Issues\n\n`;
    moderateFindings.forEach((finding, index) => {
      content += formatFinding(finding, index);
    });
  }
  
  if (lowFindings.length > 0) {
    content += `### Low Priority Issues\n\n`;
    lowFindings.forEach((finding, index) => {
      content += formatFinding(finding, index);
    });
  }
  
  content += `---\n\n`;
  content += `Generated by Bounce Automated Testing System | Framework5.2\n`;
  
  // Ensure the reports directory exists
  const reportsDir = path.join(process.cwd(), 'reports');
  await fs.mkdir(reportsDir, { recursive: true });
  
  // Write the report to a file
  const filePath = path.join(reportsDir, `bug-report-${testRunId}-${timestamp}.md`);
  await fs.writeFile(filePath, content);
  
  return filePath;
}

/**
 * Format a finding for the report
 * @param finding The finding to format
 * @param index The index of the finding
 * @returns Formatted finding text
 */
function formatFinding(finding: any, index: number): string {
  // Format Framework5.2 ID properly if missing
  const frameworkId = finding.framework_id || `PKL-278651-${finding.area.toUpperCase()}-${String(finding.id).padStart(4, '0')}-FIX`;
  
  let text = `#### Finding #${finding.id}: ${finding.title}\n\n`;
  text += `**Framework5.2 ID**: \`${frameworkId}\`\n\n`;
  text += `**Severity**: ${finding.severity}\n\n`;
  text += `**Area**: ${finding.area}\n\n`;
  text += `**Description**:\n${finding.description}\n\n`;
  
  if (finding.steps_to_reproduce) {
    text += `**Steps to Reproduce**:\n`;
    const steps = finding.steps_to_reproduce.split('\n');
    for (let i = 0; i < steps.length; i++) {
      text += `${i + 1}. ${steps[i]}\n`;
    }
    text += '\n';
  }
  
  if (finding.affected_url) {
    text += `**Affected URL**: ${finding.affected_url}\n\n`;
  }
  
  text += `---\n\n`;
  
  return text;
}

// Directly run if this module is executed on its own
if (import.meta.url === process.argv[1]) {
  // Check if a test run ID was provided
  if (process.argv.length < 3) {
    console.error('Please provide a test run ID');
    process.exit(1);
  }
  
  const testRunId = parseInt(process.argv[2], 10);
  
  generateReport(testRunId)
    .then((filePath) => {
      console.log(`Report generated: ${filePath}`);
      process.exit(0);
    })
    .catch((error) => {
      console.error(`Error generating report: ${error.message}`);
      process.exit(1);
    });
}