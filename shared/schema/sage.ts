/**
 * PKL-278651-COACH-0001-CORE
 * S.A.G.E. (Skills Assessment & Growth Engine) Schema
 * 
 * This file defines the database schema for the SAGE coaching system,
 * including coaching sessions, insights, and content library.
 * 
 * @framework Framework5.3
 * @version 1.0.0
 * @lastModified 2025-04-24
 */

import { pgTable, serial, integer, text, timestamp, boolean, jsonb } from "drizzle-orm/pg-core";
import { relations } from "drizzle-orm";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";
import { users, matches } from "../schema";

/**
 * Coaching Sessions table
 * Stores information about coaching sessions created by SAGE
 */
export const coachingSessions = pgTable("coaching_sessions", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull().references(() => users.id),
  sessionType: text("session_type").notNull(), // "match_analysis", "assessment", "training_plan"
  title: text("title").notNull(),
  summary: text("summary"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
  status: text("status").notNull().default("active"), // "active", "archived", "completed"
  relatedMatchId: integer("related_match_id").references(() => matches.id),
  metadata: jsonb("metadata").default({}).notNull(),
});

/**
 * Coaching Insights table
 * Stores individual coaching insights generated by SAGE
 */
export const coachingInsights = pgTable("coaching_insights", {
  id: serial("id").primaryKey(),
  sessionId: integer("session_id").notNull().references(() => coachingSessions.id),
  dimensionCode: text("dimension_code").notNull(), // "TECH", "TACT", "PHYS", "MENT", "CONS"
  insightType: text("insight_type").notNull(), // "strength", "weakness", "opportunity", "trend"
  title: text("title").notNull(),
  description: text("description").notNull(),
  priority: integer("priority").default(1).notNull(), // 1-5 with 5 being highest priority
  createdAt: timestamp("created_at").defaultNow().notNull(),
  isArchived: boolean("is_archived").default(false).notNull(),
  metadata: jsonb("metadata").default({}).notNull(),
});

/**
 * Training Plans table
 * Stores training plans generated by SAGE
 */
export const trainingPlans = pgTable("training_plans", {
  id: serial("id").primaryKey(),
  sessionId: integer("session_id").notNull().references(() => coachingSessions.id),
  title: text("title").notNull(),
  description: text("description").notNull(),
  durationDays: integer("duration_days").notNull(),
  difficultyLevel: integer("difficulty_level").notNull(), // 1-5 scale
  focusAreas: text("focus_areas").notNull(), // Comma-separated dimension codes
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
  status: text("status").notNull().default("active"), // "active", "completed", "archived"
  metadata: jsonb("metadata").default({}).notNull(),
});

/**
 * Training Exercises table
 * Stores exercises included in training plans
 */
export const trainingExercises = pgTable("training_exercises", {
  id: serial("id").primaryKey(),
  planId: integer("plan_id").notNull().references(() => trainingPlans.id),
  title: text("title").notNull(),
  description: text("description").notNull(),
  instructions: text("instructions").notNull(),
  durationMinutes: integer("duration_minutes").notNull(),
  dimensionCode: text("dimension_code").notNull(), // "TECH", "TACT", "PHYS", "MENT", "CONS"
  difficultyLevel: integer("difficulty_level").notNull(), // 1-5 scale
  equipmentNeeded: text("equipment_needed"),
  dayNumber: integer("day_number").notNull(), // Which day of the plan
  orderInDay: integer("order_in_day").notNull(), // Sequence within the day
  isCompleted: boolean("is_completed").default(false).notNull(),
  metadata: jsonb("metadata").default({}).notNull(),
});

/**
 * Coaching Content Library table
 * Stores pre-defined coaching content that can be used in insights and plans
 */
export const coachingContentLibrary = pgTable("coaching_content_library", {
  id: serial("id").primaryKey(),
  contentType: text("content_type").notNull(), // "insight", "exercise", "tip", "assessment"
  dimensionCode: text("dimension_code").notNull(), // "TECH", "TACT", "PHYS", "MENT", "CONS"
  title: text("title").notNull(),
  content: text("content").notNull(),
  skillLevel: text("skill_level").notNull(), // "beginner", "intermediate", "advanced"
  tags: text("tags").notNull(), // Comma-separated tags
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
  metadata: jsonb("metadata").default({}).notNull(),
});

/**
 * User Progress Logs table
 * Tracks user progress through coaching sessions and exercises
 */
export const userProgressLogs = pgTable("user_progress_logs", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull().references(() => users.id),
  sessionId: integer("session_id").references(() => coachingSessions.id),
  planId: integer("plan_id").references(() => trainingPlans.id),
  exerciseId: integer("exercise_id").references(() => trainingExercises.id),
  progressType: text("progress_type").notNull(), // "session_completed", "exercise_completed", "assessment"
  notes: text("notes"),
  rating: integer("rating"), // User rating 1-5
  createdAt: timestamp("created_at").defaultNow().notNull(),
  metadata: jsonb("metadata").default({}).notNull(),
});

// Define relationships between tables
export const coachingSessionsRelations = relations(coachingSessions, ({ one, many }) => ({
  user: one(users, {
    fields: [coachingSessions.userId],
    references: [users.id],
  }),
  insights: many(coachingInsights),
  trainingPlans: many(trainingPlans),
  progressLogs: many(userProgressLogs),
}));

export const coachingInsightsRelations = relations(coachingInsights, ({ one }) => ({
  session: one(coachingSessions, {
    fields: [coachingInsights.sessionId],
    references: [coachingSessions.id],
  }),
}));

export const trainingPlansRelations = relations(trainingPlans, ({ one, many }) => ({
  session: one(coachingSessions, {
    fields: [trainingPlans.sessionId],
    references: [coachingSessions.id],
  }),
  exercises: many(trainingExercises),
  progressLogs: many(userProgressLogs),
}));

export const trainingExercisesRelations = relations(trainingExercises, ({ one }) => ({
  plan: one(trainingPlans, {
    fields: [trainingExercises.planId],
    references: [trainingPlans.id],
  }),
}));

export const userProgressLogsRelations = relations(userProgressLogs, ({ one }) => ({
  user: one(users, {
    fields: [userProgressLogs.userId],
    references: [users.id],
  }),
  session: one(coachingSessions, {
    fields: [userProgressLogs.sessionId],
    references: [coachingSessions.id],
  }),
  plan: one(trainingPlans, {
    fields: [userProgressLogs.planId],
    references: [trainingPlans.id],
  }),
  exercise: one(trainingExercises, {
    fields: [userProgressLogs.exerciseId],
    references: [trainingExercises.id],
  }),
}));

// Create Zod schemas for insertion validation
export const insertCoachingSessionSchema = createInsertSchema(coachingSessions);
export const insertCoachingInsightSchema = createInsertSchema(coachingInsights);
export const insertTrainingPlanSchema = createInsertSchema(trainingPlans);
export const insertTrainingExerciseSchema = createInsertSchema(trainingExercises);
export const insertCoachingContentLibrarySchema = createInsertSchema(coachingContentLibrary);
export const insertUserProgressLogSchema = createInsertSchema(userProgressLogs);

// Export types
export type CoachingSession = typeof coachingSessions.$inferSelect;
export type InsertCoachingSession = typeof coachingSessions.$inferInsert;

export type CoachingInsight = typeof coachingInsights.$inferSelect;
export type InsertCoachingInsight = typeof coachingInsights.$inferInsert;

export type TrainingPlan = typeof trainingPlans.$inferSelect;
export type InsertTrainingPlan = typeof trainingPlans.$inferInsert;

export type TrainingExercise = typeof trainingExercises.$inferSelect;
export type InsertTrainingExercise = typeof trainingExercises.$inferInsert;

export type CoachingContentLibrary = typeof coachingContentLibrary.$inferSelect;
export type InsertCoachingContentLibrary = typeof coachingContentLibrary.$inferInsert;

export type UserProgressLog = typeof userProgressLogs.$inferSelect;
export type InsertUserProgressLog = typeof userProgressLogs.$inferInsert;

// Export dimension codes as a type for type safety
export const DimensionCodes = {
  TECH: "TECH", // Technical Skills
  TACT: "TACT", // Tactical Awareness
  PHYS: "PHYS", // Physical Fitness
  MENT: "MENT", // Mental Toughness
  CONS: "CONS", // Consistency
} as const;

export type DimensionCode = keyof typeof DimensionCodes;

// Export insight types as a type for type safety
export const InsightTypes = {
  strength: "strength",
  weakness: "weakness",
  opportunity: "opportunity",
  trend: "trend",
  recommendation: "recommendation",
} as const;

export type InsightType = keyof typeof InsightTypes;

// Export mood types for journaling as a type for type safety
export const MoodTypes = {
  excellent: "excellent",
  good: "good",
  neutral: "neutral",
  low: "low",
  poor: "poor",
} as const;

export type MoodType = keyof typeof MoodTypes;

// Export session types as a type for type safety
export const SessionTypes = {
  match_analysis: "match_analysis",
  assessment: "assessment",
  training_plan: "training_plan",
} as const;

export type SessionType = keyof typeof SessionTypes;

/**
 * PKL-278651-SAGE-0002-CONV 
 * SAGE Conversational UI Tables
 * These tables store conversation history between users and the SAGE coaching system
 */

/**
 * Coaching Conversations table
 * Stores conversation sessions between users and SAGE
 */
export const coachingConversations = pgTable("coaching_conversations", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull().references(() => users.id),
  title: text("title"),
  topic: text("topic"),
  dimensionFocus: text("dimension_focus"), // Optional focus on a specific dimension (TECH, TACT, etc.)
  startedAt: timestamp("started_at").defaultNow().notNull(),
  lastMessageAt: timestamp("last_message_at").defaultNow().notNull(),
  isArchived: boolean("is_archived").default(false).notNull(),
  sessionId: integer("session_id").references(() => coachingSessions.id), // Optional link to a coaching session
  metadata: jsonb("metadata").default({}).notNull(),
});

/**
 * Coaching Messages table
 * Stores individual messages within a conversation
 */
export const coachingMessages = pgTable("coaching_messages", {
  id: serial("id").primaryKey(),
  conversationId: integer("conversation_id").notNull().references(() => coachingConversations.id),
  role: text("role").notNull(), // "user", "sage", "system"
  content: text("content").notNull(),
  sentAt: timestamp("sent_at").defaultNow().notNull(),
  feedback: text("feedback"), // "positive", "negative", null
  metadata: jsonb("metadata").default({}).notNull(),
});

// Define relationships
export const coachingConversationsRelations = relations(coachingConversations, ({ one, many }) => ({
  user: one(users, {
    fields: [coachingConversations.userId],
    references: [users.id],
  }),
  session: one(coachingSessions, {
    fields: [coachingConversations.sessionId],
    references: [coachingSessions.id],
  }),
  messages: many(coachingMessages),
}));

export const coachingMessagesRelations = relations(coachingMessages, ({ one }) => ({
  conversation: one(coachingConversations, {
    fields: [coachingMessages.conversationId],
    references: [coachingConversations.id],
  }),
}));

// Create Zod schemas for insertion validation
export const insertCoachingConversationSchema = createInsertSchema(coachingConversations);
export const insertCoachingMessageSchema = createInsertSchema(coachingMessages);

// Export types
export type CoachingConversation = typeof coachingConversations.$inferSelect;
export type InsertCoachingConversation = typeof coachingConversations.$inferInsert;

export type CoachingMessage = typeof coachingMessages.$inferSelect;
export type InsertCoachingMessage = typeof coachingMessages.$inferInsert;

/**
 * PKL-278651-SAGE-0003-JOURNAL
 * SAGE Journaling System Tables
 * These tables store user journal entries and reflections for the SAGE coaching system
 */

/**
 * Journal Entries table
 * Stores user journal entries and reflections
 */
export const journalEntries = pgTable("journal_entries", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull().references(() => users.id),
  title: text("title").notNull(),
  content: text("content").notNull(),
  mood: text("mood").notNull(), // Using MoodTypes: excellent, good, neutral, low, poor
  entryType: text("entry_type").notNull(), // "free_form", "guided", "reflection", "training_log"
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
  isPrivate: boolean("is_private").default(true).notNull(),
  sessionId: integer("session_id"), // Optional link to coaching session (reference temporarily removed)
  matchId: integer("match_id").references(() => matches.id), // Optional link to match
  dimensionCode: text("dimension_code"), // Optional focus dimension
  tags: text("tags"), // Comma-separated tags
  metadata: jsonb("metadata").default({}).notNull(),
});

/**
 * Journal Prompts table
 * Stores prompts that can be used to guide journal entries
 */
export const journalPrompts = pgTable("journal_prompts", {
  id: serial("id").primaryKey(),
  promptText: text("prompt_text").notNull(),
  promptType: text("prompt_type").notNull(), // "emotional", "technical", "reflection", "goal_setting"
  dimensionCode: text("dimension_code"), // Optional focus dimension
  skillLevel: text("skill_level"), // "beginner", "intermediate", "advanced"
  isActive: boolean("is_active").default(true).notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  metadata: jsonb("metadata").default({}).notNull(),
});

/**
 * Journal Reflections table
 * Stores SAGE's reflections and insights on user journal entries
 */
export const journalReflections = pgTable("journal_reflections", {
  id: serial("id").primaryKey(),
  entryId: integer("entry_id").notNull().references(() => journalEntries.id),
  content: text("content").notNull(),
  insightType: text("insight_type").notNull(), // Using InsightTypes
  createdAt: timestamp("created_at").defaultNow().notNull(),
  isRead: boolean("is_read").default(false).notNull(),
  userFeedback: text("user_feedback"), // "helpful", "not_helpful", null
  metadata: jsonb("metadata").default({}).notNull(),
});

// Define relationships
export const journalEntriesRelations = relations(journalEntries, ({ one, many }) => ({
  user: one(users, {
    fields: [journalEntries.userId],
    references: [users.id],
  }),
  // Session relation temporarily removed
  match: one(matches, {
    fields: [journalEntries.matchId],
    references: [matches.id],
  }),
  reflections: many(journalReflections),
}));

export const journalReflectionsRelations = relations(journalReflections, ({ one }) => ({
  entry: one(journalEntries, {
    fields: [journalReflections.entryId],
    references: [journalEntries.id],
  }),
}));

// Create Zod schemas for insertion validation
export const insertJournalEntrySchema = createInsertSchema(journalEntries);
export const insertJournalPromptSchema = createInsertSchema(journalPrompts);
export const insertJournalReflectionSchema = createInsertSchema(journalReflections);

// Export types
export type JournalEntry = typeof journalEntries.$inferSelect;
export type InsertJournalEntry = typeof journalEntries.$inferInsert;

export type JournalPrompt = typeof journalPrompts.$inferSelect;
export type InsertJournalPrompt = typeof journalPrompts.$inferInsert;

export type JournalReflection = typeof journalReflections.$inferSelect;
export type InsertJournalReflection = typeof journalReflections.$inferInsert;

// Export journal entry types as a type for type safety
export const JournalEntryTypes = {
  free_form: "free_form",
  guided: "guided",
  reflection: "reflection",
  training_log: "training_log",
} as const;

export type JournalEntryType = keyof typeof JournalEntryTypes;

// Export journal prompt types as a type for type safety
export const JournalPromptTypes = {
  emotional: "emotional",
  technical: "technical",
  reflection: "reflection",
  goal_setting: "goal_setting",
} as const;

export type JournalPromptType = keyof typeof JournalPromptTypes;